use strict;
use warnings;

package Paludis::ResumeState::Serialization;

# ABSTRACT: Work with resume-files generated by Paludis

use Paludis::ResumeState::Serialization::Grammar;
use Class::Load 0.06 qw();
use Params::Util qw( _HASHLIKE _STRING);
use Carp qw();

no autovivification;

sub _get_content {
  my ($config) = shift;
  return $config->{content} if _STRING( $config->{content} );
  Carp::croak('{ content => } must be a scalar ')
    if defined $config->{content};

  return;
}

=head1 SYNOPSIS

    use Paludis::ResumeState::Serialization;

    open my $fh, '<' , '/resumefile' or die;

    my $objects = Paludis::ResumeState::Serialization->deserialize({
        content => ( do { local $/ = undef;  scalar <$fh> } ),
        format => 'basic'
    });

    my $content = Paludis::ResumeState::Serialization->serialize({
        data => $object,
        format => 'basic'
    });

    # $content should == contents of resumefile.

This class is just really a proxy serialization interface for a few of the varying back-ends.

Currently only the 'basic' back-end exists, which provides basic, but consistent serialization support.

=cut

sub _serializer {
  my ($name) = shift;
  my $formats = {
    'basic' => __PACKAGE__ . '::Basic',
    'simple_objects' => __PACKAGE__ . '::MockObjects',
    'full_objects'   => __PACKAGE__ . '::FullObjects',
  };
  my $formatnames = join q{,}, keys %{$formats};

  Carp::croak("Format Name must be a string ( in [$formatnames] ), not undef or a ref")
    unless defined $name and _STRING($name);

  Carp::croak("Format $name not in $formatnames ") unless exists $formats->{$name};
  Class::Load::load_class( $formats->{$name} );
  return $formats->{$name};
}

=head2 FormatNames

=head3 basic

Defers serialization to L<< C<::Basic>|Paludis::ResumeState::Serialization::Basic >>

=cut

=method deserialize

    my $object = ::Serialization->deserialize({
        content => $string
        format  => FormatName
    });

See L</FormatNames>

=cut

sub deserialize {
  my ( $self, $config ) = @_;

  Carp::croak( 'deserialize needs a configuration hash passed to it.' . qq{\n} . 'please see perldoc for details' )
    unless _HASHLIKE($config);

  my $content = _get_content($config);

  Carp::croak('Can\'t deserialize, no content provided, provide deserialize( hash ) with content => ')
    unless defined $content;

  Carp::croak(q[No {format=> } specified, pick 'basic'])
    unless defined $config->{format};

  return _serializer( $config->{format} )->deserialize( $config->{content} );
}

=method serialize

    my $string = ::Serialization->serialize({
        data => $object,
        format => FormatName
    });

See L</FormatNames>

=cut

sub serialize {
  my ( $self, $config ) = @_;
  return _serializer( $config->{format} )->serialize( $config->{data} );
}

1;
